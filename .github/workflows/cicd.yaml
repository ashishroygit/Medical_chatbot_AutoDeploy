name: Deploy Application Docker Image to EC2 instance

on:
  push:
    branches: [main]

jobs:
  Continuous-Integration:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Debug workspace (one-time check)
        run: |
          pwd
          ls -la
          find . -maxdepth 3 -name 'Dockerfile*' -print

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPO }}
          IMAGE_TAG: latest
        run: |
          # ensure the file is named exactly 'Dockerfile' in repo root, or add: docker build -f <path>
          docker build -t "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" .
          docker push "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  Continuous-Deployment:
    needs: Continuous-Integration
    runs-on: self-hosted
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Optional but helpful: keep the runner clean
      - name: Cleanup Docker cache
        run: |
          docker system prune -f || true
          docker builder prune -a -f || true

      - name: Pull latest image
        run: docker pull "${{ steps.login-ecr.outputs.registry }}"/"${{ secrets.ECR_REPO }}":latest

      - name: (Re)start container
        run: |
          docker rm -f app || true
          docker run --name app -d \
            --restart unless-stopped \
            --log-driver local --log-opt max-size=10m --log-opt max-file=3 \
            -p 8080:8080 \
            -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -e AWS_DEFAULT_REGION="${{ secrets.AWS_DEFAULT_REGION }}" \
            -e PINECONE_API_KEY="${{ secrets.PINECONE_API_KEY }}" \
            -e OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            "${{ steps.login-ecr.outputs.registry }}"/"${{ secrets.ECR_REPO }}":latest

      - name: Verify container is running
        run: |
          if ! docker ps --format '{{.Names}}' | grep -qx app; then
            echo "Container 'app' is not running"
            docker ps -a
            exit 1
          fi

      - name: Health check http://localhost:8080
        run: |
          for i in {1..30}; do
            if curl -sSf http://localhost:8080/ >/dev/null; then
              echo "App is up"
              exit 0
            fi
            echo "Waiting for app... ($i/30)"
            sleep 3
          done
          echo "App did not become ready in time"
          docker logs --tail=200 app || true
          exit 1
